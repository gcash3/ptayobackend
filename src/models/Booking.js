const mongoose = require('mongoose');

const { v4: uuidv4 } = require('uuid');

const bookingSchema = new mongoose.Schema({
  // Numeric booking ID for user-friendly reference (auto-generated)
  bookingId: {
    type: Number,
    unique: true,
    required: false // Will be auto-generated by pre-save hook
  },
  
  // User who made the booking
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  // Parking space being booked
  parkingSpaceId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'ParkingSpace',
    required: true
  },
  
  // Landlord who owns the parking space
  landlordId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  // Booking time details
  startTime: {
    type: Date,
    required: true
  },
  
  endTime: {
    type: Date,
    required: true
  },
  
  // Duration in hours for easier calculations
  duration: {
    type: Number,
    required: true
  },

  // Smart booking features
  bookingMode: {
    type: String,
    enum: ['reservation', 'book_now', 'smart'],
    default: 'reservation'
  },

  // Arrival prediction for "book now" mode (Enhanced with Google Maps ETA)
  arrivalPrediction: {
    estimatedTravelTime: Number, // in minutes (legacy field)
    bufferWindow: Number, // in minutes (legacy field)
    confidenceScore: Number, // 0-100
    userCurrentLocation: {
      latitude: Number,
      longitude: Number,
      timestamp: Date
    },
    predictedArrivalTime: Date,
    actualArrivalTime: Date,
    wasOnTime: Boolean,

    // Enhanced ETA fields
    realETAMinutes: Number, // Real Google Maps ETA in minutes
    gracePeriodMinutes: {
      type: Number,
      default: 15 // 15-minute grace period
    },
    maxArrivalWindow: Date, // ETA + grace period deadline
    noShowCheckTime: Date, // When to check for no-show (same as maxArrivalWindow)
    totalWindowMinutes: Number, // Total booking window (ETA + grace)

    // Real-time approach tracking
    hasEnteredApproachZone: {
      type: Boolean,
      default: false
    },
    firstApproachTimestamp: Date,
    lastApproachTimestamp: Date,
    lastLocationStatus: {
      status: String,
      zone: String,
      distance: Number,
      timestamp: Date
    },
    noShowStatus: {
      type: String,
      enum: ['pending', 'cleared', 'no_show'],
      default: 'pending'
    },
    noShowEvaluations: [{
      evaluatedAt: Date,
      result: {
        type: String,
        enum: ['pending', 'cleared', 'no_show', 'rescheduled']
      },
      reason: String,
      evidence: mongoose.Schema.Types.Mixed
    }],
    noShowCheckJobId: String,
    noShowEvaluationScheduledAt: Date,
    approachWindowExitAt: Date,

    // Enhanced factors
    factors: {
      trafficDelay: Number, // Traffic delay in minutes
      weatherImpact: Number,
      userReliability: Number,
      routeComplexity: Number,
      // New Google Maps factors
      baseTime: Number, // Base travel time without traffic
      realTime: Boolean, // Whether real Google Maps data was used
      trafficFactor: Number, // Traffic impact as percentage (0.0 - 1.0+)
      distance: Number, // Distance in kilometers
      fallback: Boolean, // Whether fallback ETA was used
      reason: String // Reason if fallback was used
    }
  },

  // Real-time tracking during transit with geo-fencing
  trackingData: {
    isActive: {
      type: Boolean,
      default: false
    },
    startedAt: Date,
    endedAt: Date,
    currentStatus: {
      type: String,
      enum: ['en_route', 'approaching', 'arrived'],
      default: 'en_route'
    },
    lastLocation: {
      latitude: Number,
      longitude: Number,
      accuracy: Number,
      timestamp: Date
    },
    lastUpdate: Date,
    locationUpdates: [{
      timestamp: Date,
      latitude: Number,
      longitude: Number,
      accuracy: Number
    }],
    geoFenceEvents: [{
      type: {
        type: String,
        enum: ['approaching', 'arrived']
      },
      timestamp: Date,
      distance: Number,
      location: {
        latitude: Number,
        longitude: Number
      }
    }],
    approachZone: {
      lastEnteredAt: Date,
      lastExitedAt: Date,
      inside: {
        type: Boolean,
        default: false
      },
      entryCount: {
        type: Number,
        default: 0
      },
      exitCount: {
        type: Number,
        default: 0
      }
    },
    notifications: [{
      type: {
        type: String,
        enum: ['eta_update', 'delay_warning', 'approaching', 'arrived']
      },
      message: String,
      timestamp: Date,
      sentTo: [{
        type: String,
        enum: ['user', 'landlord']
      }],
      geoFenceStatus: {
        status: String,
        distance: Number,
        zone: String
      }
    }]
  },
  
  // Vehicle details
  vehicleInfo: {
    plateNumber: {
      type: String,
      required: true,
      trim: true,
      uppercase: true
    },
    vehicleType: {
      type: String,
      enum: ['motorcycle', 'car'],
      required: true
    },
    vehicleColor: String,
    vehicleModel: String
  },
  
  // Booking status
  status: {
    type: String,
    enum: [
      'pending',       // Waiting for landlord approval
      'accepted',      // Approved by landlord or auto-accepted (Confirmed)
      'rejected',      // Declined by landlord
      'checked_in',    // User has arrived and checked in (manually or auto)
      'parked',        // User is confirmed parked in the space
      'checked_out',   // User has checked out (manually or auto)
      'completed',     // Completed successfully with payment settled
      'cancelled',     // Cancelled by user or system
      'expired',       // Booking expired without action
      'no_show'        // User didn't show up
    ],
    default: 'pending'
  },
  
  // Auto-accept information
  autoAccepted: {
    type: Boolean,
    default: false
  },
  
  // Response details
  responseTime: {
    type: Date // When landlord responded
  },
  
  landlordResponse: {
    action: {
      type: String,
      enum: ['accepted', 'rejected', 'auto_accepted']
    },
    message: String, // Optional message from landlord
    respondedAt: Date
  },

  // Parking Session Tracking (for usage-based billing)
  parkingSession: {
    // When status changed to 'parked' - BILLING STARTS HERE
    startTime: Date,
    // When status changed to 'completed' - BILLING ENDS HERE  
    endTime: Date,
    // Actual parking duration in minutes (usage-based)
    actualDurationMinutes: Number,
    // Whether user parked within the booking window
    arrivedWithinWindow: Boolean,
    // Parking session metadata
    sessionId: String,
    // Billing calculations
    billing: {
      standardRateMinutes: {
        type: Number,
        default: 180 // 3 hours standard rate
      },
      overtimeMinutes: Number,
      overtimeAmount: Number,
      finalAmount: Number,
      billingStartTime: Date,
      billingEndTime: Date,
      billingMethod: {
        type: String,
        enum: ['parking_session', 'fallback'],
        default: 'parking_session'
      }
    }
  },
  
  // Pricing information
  pricing: {
    hourlyRate: {
      type: Number,
      required: true
    },
    totalAmount: {
      type: Number,
      required: true
    },
    paymentMethod: {
      type: String,
      enum: ['cash', 'gcash', 'bank_transfer', 'card', 'wallet'],
      default: 'wallet'
    },
    isPaid: {
      type: Boolean,
      default: false
    },
    paidAt: Date,
    walletHoldReference: {
      type: String,
      sparse: true // Only for wallet payments
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'held', 'captured', 'released', 'failed', 'partially_refunded'],
      default: 'pending'
    }
  },
  
  // Booking selection type
  bookingType: {
    type: String,
    enum: ['traditional', 'smart'],
    default: 'traditional'
  },
  
  // Smart booking data
  smartBookingData: {
    preference: {
      type: String,
      enum: ['cheapest', 'closest', 'balanced', 'highest_rated']
    },
    originalOptions: [{
      parkingSpaceId: mongoose.Schema.Types.ObjectId,
      pricing: mongoose.Schema.Types.Mixed,
      distance: Number,
      score: Number
    }],
    selectedReason: String,
    destinationCoords: {
      latitude: Number,
      longitude: Number
    }
  },
  
  // Dynamic pricing data
  dynamicPricing: {
    basePrice: Number,
    demandFactor: Number,
    appliedFactors: [{
      type: String,
      multiplier: Number,
      description: String
    }],
    calculatedAt: Date
  },
  
  // Check-in/out tracking
  checkin: {
    time: Date,
    method: {
      type: String,
      enum: ['qr_code', 'manual', 'auto']
    },
    location: {
      latitude: Number,
      longitude: Number
    }
  },
  
  checkout: {
    time: Date,
    method: {
      type: String,
      enum: ['qr_code', 'manual', 'auto']
    },
    location: {
      latitude: Number,
      longitude: Number
    }
  },
  
  // Special instructions or notes
  notes: {
    userNotes: String,
    landlordNotes: String,
    systemNotes: String
  },
  
  // Notification tracking
  notifications: {
    landlordNotified: {
      type: Boolean,
      default: false
    },
    userNotified: {
      type: Boolean,
      default: false
    },
    reminderSent: {
      type: Boolean,
      default: false
    }
  },
  
  // Rating and review (after completion)
  rating: {
    userRating: {
      score: {
        type: Number,
        min: 1,
        max: 5
      },
      comment: String,
      ratedAt: Date
    },
    landlordRating: {
      score: {
        type: Number,
        min: 1,
        max: 5
      },
      comment: String,
      ratedAt: Date
    }
  },
  
  // Cancellation details
  cancellation: {
    cancelledBy: {
      type: String,
      enum: ['user', 'landlord', 'system']
    },
    reason: String,
    cancelledAt: Date,
    refundAmount: Number
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
bookingSchema.index({ userId: 1, createdAt: -1 });
bookingSchema.index({ landlordId: 1, createdAt: -1 });
bookingSchema.index({ parkingSpaceId: 1, startTime: 1 });
bookingSchema.index({ status: 1, createdAt: -1 });
bookingSchema.index({ startTime: 1, endTime: 1 });

// Virtual for user details
bookingSchema.virtual('user', {
  ref: 'User',
  localField: 'userId',
  foreignField: '_id',
  justOne: true
});

// Virtual for landlord details
bookingSchema.virtual('landlord', {
  ref: 'User',
  localField: 'landlordId',
  foreignField: '_id',
  justOne: true
});

// Virtual for parking space details
bookingSchema.virtual('parkingSpace', {
  ref: 'ParkingSpace',
  localField: 'parkingSpaceId',
  foreignField: '_id',
  justOne: true
});

// Calculate duration before save
bookingSchema.pre('save', function(next) {
  if (this.startTime && this.endTime) {
    const diffMs = this.endTime - this.startTime;
    this.duration = Math.ceil(diffMs / (1000 * 60 * 60)); // Convert to hours, round up
  }
  next();
});

// Calculate total amount before save (only if not already set by smart pricing)
bookingSchema.pre('save', function(next) {
  // Only calculate if totalAmount is not already set or is 0 (e.g., by smart pricing)
  if (this.duration && this.pricing.hourlyRate && (!this.pricing.totalAmount || this.pricing.totalAmount === 0)) {
    this.pricing.totalAmount = this.duration * this.pricing.hourlyRate;
  }
  next();
});

// Static method to check parking space availability
bookingSchema.statics.checkAvailability = async function(parkingSpaceId, startTime, endTime) {
  const conflictingBookings = await this.find({
    parkingSpaceId,
    status: { $in: ['accepted', 'parked'] },
    $or: [
      {
        startTime: { $lte: startTime },
        endTime: { $gt: startTime }
      },
      {
        startTime: { $lt: endTime },
        endTime: { $gte: endTime }
      },
      {
        startTime: { $gte: startTime },
        endTime: { $lte: endTime }
      }
    ]
  });
  
  return conflictingBookings.length === 0;
};

// Static method to get active bookings for a parking space
bookingSchema.statics.getActiveBookings = async function(parkingSpaceId) {
  return this.find({
    parkingSpaceId,
    status: { $in: ['accepted', 'parked'] },
    endTime: { $gt: new Date() }
  });
};

// Instance method to auto-accept booking
bookingSchema.methods.autoAccept = function() {
  this.status = 'accepted';
  this.autoAccepted = true;
  this.landlordResponse = {
    action: 'auto_accepted',
    message: 'Automatically accepted due to auto-accept settings',
    respondedAt: new Date()
  };
  this.responseTime = new Date();
  return this.save();
};

// Instance method to manually accept booking
bookingSchema.methods.accept = function(message = '') {
  this.status = 'accepted';
  this.landlordResponse = {
    action: 'accepted',
    message,
    respondedAt: new Date()
  };
  this.responseTime = new Date();
  return this.save();
};

// Instance method to reject booking
bookingSchema.methods.reject = function(reason = '') {
  this.status = 'rejected';
  this.landlordResponse = {
    action: 'rejected',
    message: reason,
    respondedAt: new Date()
  };
  this.responseTime = new Date();
  return this.save();
};

// Instance method to start parking (check-in)
bookingSchema.methods.startParking = function(location = {}) {
  const now = new Date();
  
  // Update booking status
  this.status = 'parked';
  this.checkin = {
    time: now,
    method: 'qr_code',
    location
  };
  
  // START PARKING SESSION - BILLING BEGINS HERE
  this.parkingSession = {
    startTime: now,
    endTime: null,
    actualDurationMinutes: null,
    arrivedWithinWindow: this.arrivalPrediction?.maxArrivalWindow ? 
      now <= new Date(this.arrivalPrediction.maxArrivalWindow) : null,
    sessionId: `parking_${this._id}_${Date.now()}`,
    billing: {
      standardRateMinutes: 180, // 3 hours
      billingStartTime: now,
      overtimeMinutes: 0,
      overtimeAmount: 0,
      billingMethod: 'parking_session'
    }
  };
  
  return this.save();
};

// Instance method to end parking (check-out)
bookingSchema.methods.endParking = function(location = {}) {
  const now = new Date();
  
  // Update booking status
  this.status = 'completed';
  this.checkout = {
    time: now,
    method: 'qr_code',
    location
  };
  
  // END PARKING SESSION - BILLING ENDS HERE
  if (this.parkingSession?.startTime) {
    const parkingDurationMs = now - new Date(this.parkingSession.startTime);
    const actualDurationMinutes = Math.floor(parkingDurationMs / (1000 * 60));
    
    this.parkingSession.endTime = now;
    this.parkingSession.actualDurationMinutes = actualDurationMinutes;
    this.parkingSession.billing.billingEndTime = now;
    
    // Calculate overtime based on ACTUAL PARKING TIME
    const standardMinutes = this.parkingSession.billing.standardRateMinutes;
    const overtimeMinutes = Math.max(0, actualDurationMinutes - standardMinutes);
    
    this.parkingSession.billing.overtimeMinutes = overtimeMinutes;
    
    // Calculate overtime amount
    if (overtimeMinutes > 0) {
      const overtimeHours = Math.ceil(overtimeMinutes / 60);
      const overtimeRate = 15; // ₱15 per hour
      const serviceFee = 2; // ₱2 service fee per hour
      this.parkingSession.billing.overtimeAmount = overtimeHours * (overtimeRate + serviceFee);
    } else {
      this.parkingSession.billing.overtimeAmount = 0;
    }
    
    // Calculate final amount
    const baseAmount = this.pricing?.totalAmount || 50; // Standard 3-hour rate
    this.parkingSession.billing.finalAmount = baseAmount + this.parkingSession.billing.overtimeAmount;
    
    // Update main pricing with parking session data
    if (this.pricing) {
      this.pricing.overtimeAmount = this.parkingSession.billing.overtimeAmount;
      this.pricing.finalTotalAmount = this.parkingSession.billing.finalAmount;
      this.pricing.sessionDuration = actualDurationMinutes / 60; // in hours
      this.pricing.billingMethod = 'parking_session';
    }
  }
  
  return this.save();
};

// New method: Get current parking duration
bookingSchema.methods.getCurrentParkingDuration = function() {
  if (this.status !== 'parked' || !this.parkingSession?.startTime) {
    return {
      isParked: false,
      durationMinutes: 0,
      overtimeMinutes: 0,
      estimatedAmount: this.pricing?.totalAmount || 0
    };
  }
  
  const now = new Date();
  const parkingStart = new Date(this.parkingSession.startTime);
  const durationMs = now - parkingStart;
  const durationMinutes = Math.floor(durationMs / (1000 * 60));
  
  const standardMinutes = this.parkingSession.billing?.standardRateMinutes || 180;
  const overtimeMinutes = Math.max(0, durationMinutes - standardMinutes);
  
  let estimatedAmount = this.pricing?.totalAmount || 50;
  if (overtimeMinutes > 0) {
    const overtimeHours = Math.ceil(overtimeMinutes / 60);
    estimatedAmount += overtimeHours * 17; // ₱15 + ₱2 service fee
  }
  
  return {
    isParked: true,
    durationMinutes,
    durationHours: Math.round((durationMinutes / 60) * 100) / 100,
    overtimeMinutes,
    estimatedAmount,
    arrivedWithinWindow: this.parkingSession.arrivedWithinWindow,
    standardRateMinutes: standardMinutes,
    billingStartTime: this.parkingSession.startTime
  };
};

// Auto-generate random 10-digit numeric booking ID before saving
bookingSchema.pre('save', async function(next) {
  if (this.isNew && !this.bookingId) {
    try {
      let bookingId;
      let isUnique = false;
      let attempts = 0;
      const maxAttempts = 10;
      
      // Generate a unique 10-digit random number
      while (!isUnique && attempts < maxAttempts) {
        // Generate random 10-digit number (1000000000 to 9999999999)
        bookingId = Math.floor(Math.random() * 9000000000) + 1000000000;
        
        // Check if this ID already exists
        const existingBooking = await this.constructor.findOne({ bookingId });
        isUnique = !existingBooking;
        attempts++;
      }
      
      if (!isUnique) {
        // Fallback to timestamp-based ID if all random attempts failed
        bookingId = Date.now() % 10000000000; // Ensure 10 digits
      }
      
      this.bookingId = bookingId;
      next();
    } catch (error) {
      next(error);
    }
  } else {
    next();
  }
});

// Static method to check for booking conflicts
bookingSchema.statics.checkConflicts = async function(parkingSpaceId, startTime, endTime) {
  return this.find({
    parkingSpaceId,
    status: { $in: ['pending', 'accepted', 'parked'] },
    $or: [
      {
        startTime: { $lt: endTime },
        endTime: { $gt: startTime }
      }
    ]
  });
};

// Virtual field for smart booking display info
bookingSchema.virtual('displayInfo').get(function() {
  if (this.bookingMode === 'book_now' && this.arrivalPrediction) {
    return {
      isSmartBooking: true,
      bookingTime: this.startTime,
      etaMinutes: this.arrivalPrediction.realETAMinutes,
      graceMinutes: this.arrivalPrediction.gracePeriodMinutes,
      arrivalWindow: this.arrivalPrediction.maxArrivalWindow,
      showDuration: false,
      showEndTime: false,
      billingType: 'usage_based',
      calculation: this.arrivalPrediction.realETAMinutes && this.arrivalPrediction.gracePeriodMinutes ? 
        `${this.startTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} + ${this.arrivalPrediction.realETAMinutes}min (ETA) + ${this.arrivalPrediction.gracePeriodMinutes}min grace = ${new Date(this.arrivalPrediction.maxArrivalWindow).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })} arrival window` :
        'ETA calculation available'
    };
  } else {
    return {
      isSmartBooking: false,
      startTime: this.startTime,
      endTime: this.endTime,
      duration: this.duration,
      showDuration: true,
      showEndTime: true,
      billingType: 'fixed_rate'
    };
  }
});

const Booking = mongoose.model('Booking', bookingSchema);

module.exports = Booking; 